<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¿«é€Ÿæµ‹è¯•ä¿®å¤</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test-result { margin: 10px 0; padding: 10px; border-radius: 5px; }
        .success { background-color: #d4edda; border: 1px solid #c3e6cb; }
        .error { background-color: #f8d7da; border: 1px solid #f5c6cb; }
        button { padding: 10px 20px; margin: 5px; cursor: pointer; }
        textarea { width: 100%; height: 150px; margin: 10px 0; }
    </style>
</head>
<body>
    <h2>å®¢æˆ·ç«¯ä¿®å¤éªŒè¯æµ‹è¯•</h2>
    
    <div>
        <button onclick="testRegisterSession()">æµ‹è¯•ä¼šè¯æ³¨å†Œ</button>
        <button onclick="testHeartbeat()">æµ‹è¯•å¿ƒè·³åŠŸèƒ½</button>
        <button onclick="testSendMessage()">æµ‹è¯•æ¶ˆæ¯å‘é€</button>
    </div>
    
    <div id="testResults"></div>
    
    <textarea id="functionDefs" placeholder="å‡½æ•°å®šä¹‰ï¼ˆå¯é€‰ï¼‰">[
  {
    "name": "test_function",
    "description": "æµ‹è¯•å‡½æ•°",
    "parameters": {
      "type": "object",
      "properties": {
        "test_param": {
          "type": "string",
          "description": "æµ‹è¯•å‚æ•°"
        }
      },
      "required": ["test_param"]
    }
  }
]</textarea>

    <script>
        // æ¨¡æ‹Ÿå¿…è¦çš„ç±»å’Œé…ç½®
        const Config = {
            DEFAULT_SERVER_URL: 'https://localhost:8000',
            DEFAULT_TIMEOUT: 30,
            HEARTBEAT_INTERVAL: 2 * 60 * 1000
        };

        class StateManager {
            constructor() {
                this.isConnected = false;
                this.isProcessing = false;
                this.sessionId = null;
                this.sessionExpiryTime = null;
                this.heartbeatInterval = null;
            }
            
            setConnected(connected) {
                this.isConnected = connected;
                console.log('è¿æ¥çŠ¶æ€æ›´æ–°:', connected);
            }
            
            setProcessing(processing) {
                this.isProcessing = processing;
            }
            
            setSession(sessionId, expiryTime) {
                this.sessionId = sessionId;
                this.sessionExpiryTime = expiryTime;
                console.log('ä¼šè¯è®¾ç½®:', sessionId, expiryTime);
            }
            
            clearSession() {
                this.sessionId = null;
                this.sessionExpiryTime = null;
                if (this.heartbeatInterval) {
                    clearInterval(this.heartbeatInterval);
                    this.heartbeatInterval = null;
                }
            }
        }

        class ConfigManager {
            static getServerUrl() {
                return Config.DEFAULT_SERVER_URL;
            }
            
            static getTimeout() {
                return Config.DEFAULT_TIMEOUT;
            }
            
            static getFunctionMode() {
                return document.getElementById('functionDefs').value.trim() ? 'with-functions' : 'chat-only';
            }
            
            static getFunctionDefinitions() {
                return document.getElementById('functionDefs').value.trim();
            }
            
            static getClientType() {
                return 'test-client';
            }
            
            static getClientId() {
                return 'test_' + Date.now();
            }
            
            static getSpiritId() {
                return '';
            }
            
            static getSceneType() {
                return 'public';
            }
        }

        class Toast {
            static show(message, type = 'info') {
                console.log(`Toast [${type}]:`, message);
                const resultDiv = document.getElementById('testResults');
                const toastDiv = document.createElement('div');
                toastDiv.className = `test-result ${type === 'success' ? 'success' : 'error'}`;
                toastDiv.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                resultDiv.appendChild(toastDiv);
            }
        }

        class ChatManager {
            static addBotMessage(message) {
                console.log('Botæ¶ˆæ¯:', message);
                const resultDiv = document.getElementById('testResults');
                const msgDiv = document.createElement('div');
                msgDiv.className = 'test-result success';
                msgDiv.innerHTML = `<strong>ğŸ¤– Bot:</strong> ${message.replace(/\n/g, '<br>')}`;
                resultDiv.appendChild(msgDiv);
            }
        }

        class UIController {
            static showLoading(buttonId, loadingText) {
                console.log('æ˜¾ç¤ºåŠ è½½:', buttonId, loadingText);
            }
            
            static hideLoading(buttonId, originalText) {
                console.log('éšè—åŠ è½½:', buttonId, originalText);
            }
        }

        // å…¨å±€çŠ¶æ€ç®¡ç†å™¨
        const stateManager = new StateManager();

        // ä¿®å¤åçš„NetworkManager
        class NetworkManager {
            static async registerSession() {
                const mode = ConfigManager.getFunctionMode();
                let functions = null;

                if (mode === 'with-functions') {
                    const functionDefValue = ConfigManager.getFunctionDefinitions();
                    if (functionDefValue) {
                        try {
                            const parsedFunctions = JSON.parse(functionDefValue);
                            if (Array.isArray(parsedFunctions)) {
                                functions = parsedFunctions;
                                for (let i = 0; i < functions.length; i++) {
                                    const func = functions[i];
                                    if (!func.name || !func.description || !func.parameters) {
                                        throw new Error(`ç¬¬${i+1}ä¸ªå‡½æ•°å®šä¹‰ç¼ºå°‘å¿…è¦å­—æ®µ`);
                                    }
                                }
                            } else {
                                throw new Error('å‡½æ•°å®šä¹‰å¿…é¡»æ˜¯æ•°ç»„æ ¼å¼');
                            }
                        } catch (e) {
                            Toast.show(`å‡½æ•°å®šä¹‰JSONæ ¼å¼é”™è¯¯: ${e.message}`, 'error');
                            return;
                        }
                    }
                }

                UIController.showLoading('registerBtn', 'æ³¨å†Œä¸­...');

                try {
                    const registrationData = {
                        client_metadata: {
                            client_id: ConfigManager.getClientId(),
                            client_type: ConfigManager.getClientType(),
                            client_version: "1.0.0",
                            platform: "web-test-client",
                            capabilities: {
                                max_concurrent_requests: 3,
                                supported_scenes: ["study", "leisure", "public"],
                                preferred_response_format: "json",
                                function_calling_supported: (mode === 'with-functions')
                            }
                        },
                        functions: (mode === 'with-functions' && functions) ? functions : []
                    };

                    const response = await fetch(`${ConfigManager.getServerUrl()}/api/session/register`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(registrationData),
                        signal: AbortSignal.timeout(ConfigManager.getTimeout() * 1000)
                    });

                    if (!response.ok) {
                        let errorMessage = `HTTP ${response.status}`;
                        try {
                            const errorData = await response.json();
                            errorMessage = errorData.detail || errorData.message || errorMessage;
                        } catch (e) {
                            errorMessage = `æœåŠ¡å™¨è¿”å›é”™è¯¯: ${response.status} ${response.statusText}`;
                        }
                        throw new Error(errorMessage);
                    }

                    const result = await response.json();

                    stateManager.setSession(result.session_id, new Date(result.expires_at));
                    stateManager.setConnected(true);
                    NetworkManager.startHeartbeat(); // ä¿®å¤ï¼šä½¿ç”¨ç±»åè°ƒç”¨
                    
                    let successMessage = `âœ… ä¼šè¯æ³¨å†ŒæˆåŠŸ!\n\n`;
                    successMessage += `ä¼šè¯ID: ${result.session_id}\n`;
                    successMessage += `è¿‡æœŸæ—¶é—´: ${new Date(result.expires_at).toLocaleString()}\n`;
                    successMessage += `æ”¯æŒåŠŸèƒ½: ${result.supported_features.join(', ')}\n`;
                    
                    if (mode === 'with-functions') {
                        if (functions && functions.length > 0) {
                            successMessage += `\nå·²æ³¨å†Œå‡½æ•° (${functions.length}ä¸ª):\n`;
                            functions.forEach((func, index) => {
                                successMessage += `  ${index + 1}. ${func.name}: ${func.description}\n`;
                            });
                            successMessage += `\nå½“å‰ä¸ºå‡½æ•°è°ƒç”¨æ¨¡å¼ï¼Œæ”¯æŒå¤æ‚æ“ä½œã€‚`;
                        } else {
                            successMessage += `\nå½“å‰ä¸ºå‡½æ•°è°ƒç”¨æ¨¡å¼ï¼Œä½†æœªæä¾›å‡½æ•°å®šä¹‰ï¼Œå°†ä½¿ç”¨æ™®é€šå¯¹è¯å¤„ç†ã€‚`;
                        }
                    } else {
                        successMessage += `\nå½“å‰ä¸ºæ™®é€šå¯¹è¯æ¨¡å¼ï¼Œé€‚ç”¨äºåŸºç¡€é—®ç­”å’Œå’¨è¯¢ã€‚`;
                    }

                    Toast.show('ä¼šè¯æ³¨å†ŒæˆåŠŸï¼', 'success');
                    ChatManager.addBotMessage(successMessage);
                } catch (error) {
                    console.error('æ³¨å†Œä¼šè¯å¤±è´¥:', error);
                    Toast.show(`æ³¨å†Œå¤±è´¥: ${error.message}`, 'error');
                    ChatManager.addBotMessage(`âŒ ä¼šè¯æ³¨å†Œå¤±è´¥: ${error.message}`);
                } finally {
                    UIController.hideLoading('registerBtn', 'æ³¨å†Œä¼šè¯');
                }
            }

            static startHeartbeat() {
                if (stateManager.heartbeatInterval) {
                    clearInterval(stateManager.heartbeatInterval);
                }
                
                stateManager.heartbeatInterval = setInterval(async () => {
                    if (stateManager.sessionId) {
                        try {
                            const response = await fetch(`${ConfigManager.getServerUrl()}/api/session/heartbeat`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'session-id': stateManager.sessionId
                                },
                                signal: AbortSignal.timeout(5000)
                            });
                            
                            if (!response.ok) {
                                console.warn('å¿ƒè·³å¤±è´¥:', response.status);
                                stateManager.clearSession();
                            } else {
                                stateManager.setConnected(true);
                            }
                        } catch (error) {
                            console.warn('å¿ƒè·³è¯·æ±‚å¼‚å¸¸:', error);
                            if (error.name !== 'AbortError') {
                                stateManager.setConnected(false);
                            }
                        }
                    }
                }, Config.HEARTBEAT_INTERVAL);
            }

            static async processMessage(message) {
                stateManager.setProcessing(true);
                UIController.showLoading('sendBtn', 'å¤„ç†ä¸­...');
                
                try {
                    const requestData = {
                        user_input: message,
                        client_type: ConfigManager.getClientType(),
                        spirit_id: ConfigManager.getSpiritId(),
                        scene_type: ConfigManager.getSceneType()
                    };

                    const headers = {
                        'Content-Type': 'application/json',
                    };
                    
                    if (stateManager.sessionId) {
                        headers['session-id'] = stateManager.sessionId;
                    }

                    const response = await fetch(`${ConfigManager.getServerUrl()}/api/agent/parse`, {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify(requestData),
                        signal: AbortSignal.timeout(ConfigManager.getTimeout() * 1000)
                    });

                    const result = await response.json();

                    if (response.ok) {
                        NetworkManager.handleSuccessResponse(result); // ä¿®å¤ï¼šä½¿ç”¨ç±»åè°ƒç”¨
                    } else {
                        NetworkManager.handleErrorResponse(result, response.status); // ä¿®å¤ï¼šä½¿ç”¨ç±»åè°ƒç”¨
                    }

                } catch (error) {
                    NetworkManager.handleNetworkError(error); // ä¿®å¤ï¼šä½¿ç”¨ç±»åè°ƒç”¨
                } finally {
                    stateManager.setProcessing(false);
                    UIController.hideLoading('sendBtn', 'å‘é€');
                }
            }

            static handleSuccessResponse(result) {
                if (result.code === 200 && result.data) {
                    const command = result.data;
                    const rawResponse = JSON.stringify(command, null, 2);
                    ChatManager.addBotMessage(rawResponse);
                } else {
                    ChatManager.addBotMessage(`è¯·æ±‚å¤„ç†å¤±è´¥: ${result.msg || 'æœªçŸ¥é”™è¯¯'}`);
                }
            }

            static handleErrorResponse(result, status) {
                let errorMsg = `è¯·æ±‚å¤±è´¥ (${status})`;
                if (result.msg) {
                    errorMsg = result.msg;
                } else if (status === 404) {
                    errorMsg = 'æœªæŸ¥è¯¢åˆ°ç›¸å…³æ–‡ç‰©æ•°æ®';
                } else if (status === 400) {
                    errorMsg = 'è¯·æ±‚å‚æ•°é”™è¯¯';
                } else if (status === 401) {
                    errorMsg = 'æ¥å£è®¤è¯å¤±è´¥';
                }
                ChatManager.addBotMessage(errorMsg);
            }

            static handleNetworkError(error) {
                if (error.name === 'AbortError') {
                    ChatManager.addBotMessage('è¯·æ±‚è¶…æ—¶ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨åœ°å€å’Œç½‘ç»œè¿æ¥');
                } else {
                    ChatManager.addBotMessage(`ç½‘ç»œé”™è¯¯: ${error.message}`);
                }
            }
        }

        // å…¨å±€å‡½æ•°
        function testRegisterSession() {
            NetworkManager.registerSession();
        }

        function testHeartbeat() {
            if (stateManager.sessionId) {
                NetworkManager.startHeartbeat();
                Toast.show('å¿ƒè·³æµ‹è¯•å·²å¯åŠ¨', 'success');
            } else {
                Toast.show('è¯·å…ˆæ³¨å†Œä¼šè¯', 'error');
            }
        }

        function testSendMessage() {
            if (stateManager.sessionId) {
                NetworkManager.processMessage('ä½ å¥½ï¼Œè¿™æ˜¯ä¸€ä¸ªæµ‹è¯•æ¶ˆæ¯');
            } else {
                Toast.show('è¯·å…ˆæ³¨å†Œä¼šè¯', 'error');
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆæç¤º
        document.addEventListener('DOMContentLoaded', function() {
            Toast.show('æµ‹è¯•é¡µé¢åŠ è½½å®Œæˆï¼Œè¯·ç‚¹å‡»æŒ‰é’®è¿›è¡Œæµ‹è¯•', 'success');
        });
    </script>
</body>
</html>